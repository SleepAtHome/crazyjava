类的加载、连接和初始化
系统可能在第一次使用某个类时加载该类、也可能采用预加载机制加载某个类。

18.1.1 JVM和类：
当调用Java命令运行某个Java程序时，该命令将会启动一个JVM进程。
同一个JVM的所有线程、所有变量都处于同一个进程里，它们都使用该JVM的内存区。

以下情况JVM进程将被终止：
- 程序运行到最后正常结束
- 使用System.exit() 或 Runtime.getRuntime().exit()
- 程序执行过程中遇到未捕获的异常或错误 而结束
- 程序所在平台强制结束了JVM进程

当Java程序运行结束时，JVM进程结束，改进程在内存中的状态会丢失。


18.1.2 类的加载：
当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会加载、连接、初始化3个步骤对该类进行初始化。

类加载：将类的class文件读入内存，并为之创建一个java.lang.Class对象。（使用任何类都会这样）
类的加载通过类加载器（由JVM提供）完成——系统类加载器。
我们可以通过继承ClassLoader来创建自己的类加载器。

类加载器数据来源：
- 从本地文件系统加载class文件（大部分）
- 从jar包加载class文件（例如jdbc编程时用到的数据库驱动）
- 通过网络加载class文件
- 把一个Java源文件动态编译，并执行加载

类加载器通常无需等到"首次使用"该类时才加载该类，JVM运行规范允许系统预先加载某些类。


18.1.3 类的连接：
当类被加载之后，系统为之生成了一个对应的java.lang.Class对象，接下来进入连接阶段。
连接阶段负责把类的二进制数据合并到JRE中（分为以下3个阶段）：
1. 验证：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。
2. 准备：负责为类的静态Field分配内存，并设置默认初始值。
3. 解析：将类的二进制数据中的符号引用替换成直接引用。


18.1.4 类的初始化：
在类的初始化阶段，JVM负责对类进行初始化，主要就是对静态Field进行初始化。

Java中对静态Field指定初始值有两种方式：1. 声明静态Field时指定初始值。 2.使用静态初始化块为静态Field指定初始值。

声明变量时指定初始值、静态初始化块都将被当成类的初始化语句。

JVM初始化一个类步骤如下：
1. 假如这个类还没有被加载和连接，则程序先加载并连接该类。
2. 假如该类的直接父类还没有被初始化，则先初始化其直接父类。（对父类也执行1~3步骤）
3. 假如类中有初始化语句，则系统依次执行这些初始化语句。

所以JVM最先初始化的总是java.lang.Object类。
当程序主动使用任何一个类时，系统会保证该类及其所有父类（包括直接父类和间接父类）都会被初始化。


18.1.5 类初始化的时机：
当Java程序通过下面6种方式来使用某个类或接口时，系统就会初始化该类或接口：
- 创建类的实例。（new、反射、反序列化）
- 调用某个类的静态方法
- 访问某个类或接口的静态Field、或为该静态Field赋值
- 使用反射方式类强制创建某个类或接口对应的java.lang.Class对象。（e.g. Class.forName("Person") 如果系统还未初始化Person类，则这行代码将会导致该Person类被初始化，并返回Person类对应的java.lang.Class对象。)
- 初始化某个类的子类。当初始化某个类的子类时，该子类的所有父类都会被初始化。
- 直接使用java.exe 命令来运行某个主类。当运行某个主类时，系统会先初始化该主类。

特别指出：
对于一个final型的静态Field，如果该Field的值在编译时就可以确定下来，那么这个Field相当于"宏变量"。
Java编译器会在编译时直接把这个Field出现的地方替换成它的值。
因此，即使程序使用该静态Field，也不会导致该类的初始化。

当使用ClassLoader类的loadClass()方法来加载某个类时，该方法只是加载该类，并不会执行该类的初始化。
使用Class的forName()静态方法才会导致强制初始化该类。



