类加载器：
负责将.class文件加载到内存中，并为之生成java.lang.Class对象。

18.2.1 类加载器 简介
一旦一个类被载入JVM中，同一个类就不会再次载入了。

一个类用其全限定名（包名+类名）作为标识。
但在JVM中，一个类用 其全限定类名+其类加载器 作为唯一标识。

e.g. 在pg的包中含有一个Person类，被类加载器ClassLoader的实例kl1负责加载，则该Person类对应的Class对象在JVM中表示为（Person、pg、kl1）
     意味着两个类加载器的同名类：（Person、pg、kl1）和（Person、pg、kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。

当JVM启动时，会形成由3个类加载器组成的初始类加载器层次结构：
- Bootstrap ClassLoader：根类加载器——加载Java的核心类（Java核心类库都在jdk1.x.x_xxx/jre/lib/rt.jar文件中）
- Extension ClassLoader：扩展类加载器——加载JRE的扩展目录（jdk1.x.x_xxx/jre/lib/ext或者由java.ext.dirs系统指定的目录）中JAR包的类。
- System ClassLoader：系统（应用）类加载器——在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性，或CLASSPATH环境变量所制定的JAR包和类路径。
    程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。
    如果没有特别指定，则用户自定义的类加载器都以类加载器作为父加载器。

根类加载器很特殊，不是java.lang.ClassLoader的子类，而是由JVM自身实现的。


18.2.2 类加载机制
JVM的类加载机制有3种：
- 全盘负责：当一个类加载器加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入。（除非显式使用另外一个类加载器来载入）
- 父类委托：先让parent类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。
- 缓存机制：保证所有加载过的Class都会被缓存。（修改了Class后，必须重新启动JVM才能生效）

类加载器之间不是继承关系。

开发者可以自定义类加载器（通过继承ClassLoader实现）
JVM中4种类加载器的层次结构：根类加载器<--扩展类加载器<--系统类加载器<--用户类加载器

类加载器加载Class大致有以下8个步骤：
1. 检测此Class是否载入过。（有-->8）
2. 如果父类加载器不存在-->4（如果没有父类加载器，要么parent一定是根类加载器，要么本身就是根类加载器）。
3. 请求使用父类加载器载入目标类。（成功载入-->8；不成功-->5）
4. 请求使用根类加载器来载入目标类。（成功载入-->8；不成功-->7）
5. 当前类加载器尝试寻找Class文件（从与此CLassLoader相关的类路径中寻找）（找到-->6；找不到-->7）
6. 从文件中载入Class。（成功-->8）
7. 抛出ClassNotFoundException。
8. 返回对应的java.lang.Class对象。
其中 5、6步允许重写CLassLoader的findCLass()方法来实现自己的载入策略，也可以重写loadClass()方法来实现自己的载入过程。


