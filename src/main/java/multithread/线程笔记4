16.5 线程同步
当使用多个线程来访问同一个数据时，很容易出现线程安全问题。

银行取钱的问题，在drawMoney包下。

同步代码块：
run()方法不具有同步安全性——有两个并发线程在修改Account对象。
可以使用同步代码块解决线程安全问题：

synchronized(obj){...}
obj:同步监视器
...:被同步的代码部分

线程在执行同步代码块之前，必须先获得对同步监视器的锁定。
任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程会释放对该同步监视器的锁定。

同步监视器的目的：阻止两个线程对同一个共享资源进行并发访问，因此通常推荐使用可能被并发访问的共享资源充当同步监视器。
对于上面银行取钱的问题，可以使用Account的对象作为同步监视器。


同步方法：使用synchronized来修饰某个方法
同步方法无需显式指定同步监视器，同步方法的同步监视器是this，也就是该对象本身。

线程安全类的特征：
- 该类的对象可以被多个线程安全地访问
- 每个线程调用该对象的任意方法之后都将得到正确的结果
- 每个线程调用该对象的任意方法之后，该对象状态依然保持合理状态

不可变类总是线程安全的，因为它的对象状态不可变。
可变类的线程安全是以降低程序的运行效率作为代价的。
- 不要对线程安全类的所有方法都进行同步，只对那些会改变的竞争资源（共享资源）的方法进行同步。例如accountNo属性就无需同步。
- 如果可变类有两种运行环境：单线程和多线程环境，则应该为该可变类提供两种版本。例如StringBuilder-单线程、StringBuffer-多线程。



释放同步监视器的锁定：（程序无法显式释放对同步监视器的锁定）
- 当前线程的同步方法、同步代码块执行结束，当前线程释放同步监视器
- 当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行，会释放
- 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致改代码块、该方法异常结束时，会释放
- 当前线程执行同步代码块、同步方法时，程序执行了同步监视器对象的wait()方法，则当前线程暂停，释放

不会释放同步监视器的锁定：
- 线程执行同步代码块、同步方法时，调用了Thread.sleep()、Thread.yield()来暂停当前线程的执行，不会释放
- 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，不会释放
（避免使用suspend()、resume()方法控制线程）


